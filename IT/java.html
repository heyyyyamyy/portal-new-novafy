
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Novafy Portal</title>
    <link rel="stylesheet" href="/style.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css">
</head>

<body>
    <header class="container-fluid " id="nav-bar-bg">
        <div class="container py-3">
            <div class="row ">
                <div class="col-12 col-xl-12">
                    <img src="https://novafyasia.in/company_logo-removebg-preview(1).png" class="img-fluid " alt="">
                </div>
            </div>
        </div>
    </header>

    <section class="container-fluid">

        <h1>Java Developer</h1>
1. **What is Java, and why is it called platform-independent?**
   - Java is a high-level, object-oriented programming language. Its platform independence comes from the use of the Java Virtual Machine (JVM), which interprets bytecode generated by the Java compiler and runs it on different platforms.
2. **Explain the key concepts of object-oriented programming (OOP) in Java:**
   - Classes, objects, encapsulation, inheritance, polymorphism, and abstraction.
3. **Differentiate between primitive data types and reference types in Java.**
   - Primitive data types (int, float, char, etc.) are basic building blocks, stored directly in memory. Reference types (objects of classes) store memory addresses of actual data.
4. **Explain the purpose and syntax of access modifiers (public, private, protected, default) in Java.**
   - They control the accessibility of classes, methods, and fields within a package or across packages.
5. **Describe the difference between final, finalize, and finally keywords in Java.**
   - `final`: Restricts modifications (class can't be extended, method can't be overridden, variable becomes constant).
   - `finalize`: Method called by the garbage collector before object removal, but not for guaranteed cleanup. Use `try-with-resources` instead.
   - `finally`: Block of code always executed after a `try` block, regardless of exceptions (useful for resource cleanup).
6. **Explain the concept of inheritance in Java and its benefits.**
   - Inheriting properties and behavior from a parent class, promoting code reusability and maintainability.
7. **Differentiate between method overloading and overriding in Java.**
   - Overloading: Having multiple methods with the same name but different parameters (argument types or number).
   - Overriding: Redefining inherited methods in a subclass to provide a specialized implementation.
8. **Explain the differences between abstract classes and interfaces in Java.**
   - `abstract class`: Provides partial implementation and can have non-abstract methods; subclasses must implement abstract methods.
   - `interface`: Declares abstract methods and may have static and default methods; multiple interfaces can be implemented by a class.
9. **Describe the mechanism of garbage collection in Java.**
   - Automatic reclaiming of memory occupied by unused objects, managed by the JVM.
10. **What are the different types of exceptions in Java, and how do you handle them using try-catch blocks?**
   - Checked (compile-time) and unchecked (runtime) exceptions; `try-catch` blocks enclose code and handle specific exceptions.

**Java Collections Framework (11-20):**

11. **Explain the purpose and basic operations of the List interface in Java.**
   - Ordered collection of unique or duplicate objects; common implementations include `ArrayList`, `LinkedList`.
12. **Differentiate between ArrayList and LinkedList in Java.**
   - `ArrayList`: Faster random access, slower insertions/deletions (array-based).
   - `LinkedList`: Faster insertions/deletions, slower random access (doubly linked list).
13. **Explain the Set interface and its common implementations in Java.**
   - Unordered collection of unique elements; common implementations include `HashSet`, `TreeSet`.
14. **Differentiate between HashSet and TreeSet in Java.**
   - `HashSet`: Faster average performance, not ordered (based on hash table).
   - `TreeSet`: Slower for most operations, elements are automatically sorted (based on a tree structure).
15. **Describe the purpose and basic operations of the Map interface in Java.**
   - Associates unique keys with values; common implementations include `HashMap`, `TreeMap`.
16. **Differentiate between HashMap and TreeMap in Java.**
   - `HashMap`: Faster average performance, not ordered (based on hash table).
   - `TreeMap`: Slower for most operations, elements are automatically sorted (based on a tree structure).
17. **Explain the concept of generics in Java and their benefits.**
   - Type safety, preventing runtime errors due to incorrect object types.
18. **Describe the ConcurrentModificationException and how to avoid it.**
   - Occurs when modifying a collection while iterating over it; use `Iterator.remove()` or `ConcurrentHashMap`.
19. **What is the difference between concurrent and parallel collections in Java?**
   - `concurrent`: Multiple threads can access and modify the collection safely (e.g., `ConcurrentHashMap`).
   - `parallel`: Operations are split across multiple threads for

   **Data Structures & Algorithms (21-30):**

   21. **Explain the concept of a Stack and its common operations.**
      - LIFO (Last-In-First-Out) data structure; operations include `push`, `pop`, `peek`, `isEmpty`.
   22. **Describe a Queue and its common operations.**
      - FIFO (First-In-First-Out) data structure; operations include `enqueue`, `dequeue`, `peek`, `isEmpty`.
   23. **Explain the difference between linked lists and arrays in Java.**
      - Linked lists: Dynamically allocated, more flexible for insertions/deletions, slower random access.
      - Arrays: Fixed size, efficient random access, slower insertions/deletions.
   24. **Describe the time and space complexities of common sorting algorithms (e.g., Bubble Sort, Selection Sort, Insertion Sort, Merge Sort, Quick Sort).**
      - Research time and space complexity (Big O notation) for each algorithm to understand their efficiency trade-offs.
   25. **Explain the concept of searching algorithms (e.g., Linear Search, Binary Search) and their time complexities.**
      - Research time complexity (Big O notation) for each algorithm to understand their performance characteristics.
   
   **Java I/O, Networking, & Threads (31-40):**
   
   26. **Explain the difference between character streams and byte streams in Java I/O.**
      - Character streams deal with text data, while byte streams handle raw bytes.
   27. **Describe the use of the `try-with-resources` statement for resource management in Java.**
      - Ensures automatic closing of resources, preventing resource leaks.
   28. **Explain the difference between blocking and non-blocking I/O in Java.**
      - Blocking I/O: Thread waits for I/O operation to complete.
      - Non-blocking I/O: Thread continues execution while I/O operation awaits.
   29. **Describe the purpose of the `Socket` class and its use for network communication.**
      - Establishes network connections for TCP/IP communication.
   30. **Explain the concept of multithreading in Java and its benefits and challenges.**
      - Allows concurrent execution of multiple tasks for improved performance and responsiveness, but introduces synchronization challenges.
   
   **Java Concurrency & Advanced Topics (41-50):**
   
   31. **Describe the `synchronized` keyword and its use for thread synchronization.**
      - Ensures only one thread can access a shared resource at a time.
   32. **Explain the difference between reentrant and non-reentrant locks.**
      - Reentrant locks can be acquired by the same thread multiple times without deadlock.
   33. **Describe the Java Semaphore class and its usage.**
      - Controls access to a limited number of resources, preventing overconsumption.
   34. **Explain the purpose of Java ExecutorService and its common thread pool implementations.**
      - Manages a pool of threads for efficient execution of asynchronous tasks.
   35. **Describe the advantages and disadvantages of using Java lambdas (functional interfaces).**
      - Concise way to express anonymous functions, promote code brevity, can lead to readability concerns if overused.
   
   **Java Development Best Practices & Testing (46-50):**
   
   36. **Explain the importance of code documentation and different documentation techniques.**
      - Improves code maintainability, understanding, and collaboration. Techniques include comments, Javadoc, UML diagrams.
   37. **Describe common design patterns used in Java development (e.g., Singleton, Factory Method, Adapter).**
      - Reusable solutions to common problems; research specific design patterns for their applications.
   38. **Explain the benefits of using unit testing and integration testing in Java development.**
      - Unit testing verifies individual units of code (e.g., methods); integration testing checks interaction between components.
   39. **Describe the use of different testing frameworks in Java (e.g., JUnit, Mockito).**
      - JUnit: Popular framework for unit testing; Mockito: Provides mocks and stubs for unit testing.
   40. **Explain the importance of continuous integration and continuous delivery (CI/CD) in Java development.**
      - Automates code building, testing, and deployment, promoting faster and more reliable development cycles.
    </section>

    <footer class="bg-black py-3">
        <h4 class="text-center text-white">@inHouse Novafy</h4>
    </footer>




    <script src="script.js"></script>
    <script src="bootstrap-5.3.2-dist/js/bootstrap.bundle.js"></script>

</body>

</html>
